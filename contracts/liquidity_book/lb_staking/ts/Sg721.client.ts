/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.3.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { ExecuteMsg, Uint256, Addr, Binary, Uint128, TokenType, RewardsDistribution, Snip1155ReceiveMsg, Snip20ReceiveMsg, ContractInfo, RawContract, InstantiateMsg, InvokeMsg, QueryAnswer, TxAction, Contract, RewardTokenInfo, OwnerBalance, Liquidity, Tx, Reward, RewardToken, QueryMsg, Auth, QueryTxnType, PermitForPermitData, PermitData, PermitSignature, PubKey } from "./Sg721.types";
export interface Sg721ReadOnlyInterface {
  contractAddress: string;
  contractInfo: () => Promise<ContractInfoResponse>;
  epochInfo: ({
    index
  }: {
    index?: number;
  }) => Promise<EpochInfoResponse>;
  registeredTokens: () => Promise<RegisteredTokensResponse>;
  idTotalBalance: ({
    id
  }: {
    id: string;
  }) => Promise<IdTotalBalanceResponse>;
  balance: ({
    auth,
    tokenId
  }: {
    auth: Auth;
    tokenId: string;
  }) => Promise<BalanceResponse>;
  stakerInfo: ({
    auth
  }: {
    auth: Auth;
  }) => Promise<StakerInfoResponse>;
  allBalances: ({
    auth,
    page,
    pageSize
  }: {
    auth: Auth;
    page?: number;
    pageSize?: number;
  }) => Promise<AllBalancesResponse>;
  liquidity: ({
    auth,
    roundIndex,
    tokenIds
  }: {
    auth: Auth;
    roundIndex?: number;
    tokenIds: number[];
  }) => Promise<LiquidityResponse>;
  transactionHistory: ({
    auth,
    page,
    pageSize,
    txnType
  }: {
    auth: Auth;
    page?: number;
    pageSize?: number;
    txnType: QueryTxnType;
  }) => Promise<TransactionHistoryResponse>;
}
export class Sg721QueryClient implements Sg721ReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.contractInfo = this.contractInfo.bind(this);
    this.epochInfo = this.epochInfo.bind(this);
    this.registeredTokens = this.registeredTokens.bind(this);
    this.idTotalBalance = this.idTotalBalance.bind(this);
    this.balance = this.balance.bind(this);
    this.stakerInfo = this.stakerInfo.bind(this);
    this.allBalances = this.allBalances.bind(this);
    this.liquidity = this.liquidity.bind(this);
    this.transactionHistory = this.transactionHistory.bind(this);
  }

  contractInfo = async (): Promise<ContractInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      contract_info: {}
    });
  };
  epochInfo = async ({
    index
  }: {
    index?: number;
  }): Promise<EpochInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      epoch_info: {
        index
      }
    });
  };
  registeredTokens = async (): Promise<RegisteredTokensResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      registered_tokens: {}
    });
  };
  idTotalBalance = async ({
    id
  }: {
    id: string;
  }): Promise<IdTotalBalanceResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      id_total_balance: {
        id
      }
    });
  };
  balance = async ({
    auth,
    tokenId
  }: {
    auth: Auth;
    tokenId: string;
  }): Promise<BalanceResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      balance: {
        auth,
        token_id: tokenId
      }
    });
  };
  stakerInfo = async ({
    auth
  }: {
    auth: Auth;
  }): Promise<StakerInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      staker_info: {
        auth
      }
    });
  };
  allBalances = async ({
    auth,
    page,
    pageSize
  }: {
    auth: Auth;
    page?: number;
    pageSize?: number;
  }): Promise<AllBalancesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      all_balances: {
        auth,
        page,
        page_size: pageSize
      }
    });
  };
  liquidity = async ({
    auth,
    roundIndex,
    tokenIds
  }: {
    auth: Auth;
    roundIndex?: number;
    tokenIds: number[];
  }): Promise<LiquidityResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      liquidity: {
        auth,
        round_index: roundIndex,
        token_ids: tokenIds
      }
    });
  };
  transactionHistory = async ({
    auth,
    page,
    pageSize,
    txnType
  }: {
    auth: Auth;
    page?: number;
    pageSize?: number;
    txnType: QueryTxnType;
  }): Promise<TransactionHistoryResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      transaction_history: {
        auth,
        page,
        page_size: pageSize,
        txn_type: txnType
      }
    });
  };
}
export interface Sg721Interface extends Sg721ReadOnlyInterface {
  contractAddress: string;
  sender: string;
  claimRewards: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  endEpoch: ({
    epochIndex,
    rewardsDistribution
  }: {
    epochIndex: number;
    rewardsDistribution: RewardsDistribution;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  unstake: ({
    amounts,
    tokenIds
  }: {
    amounts: Uint256[];
    tokenIds: number[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  snip1155Receive: ({
    amount,
    from,
    memo,
    msg,
    sender,
    tokenId
  }: {
    amount: Uint256;
    from: Addr;
    memo?: string;
    msg?: Binary;
    sender: Addr;
    tokenId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  receive: ({
    amount,
    from,
    memo,
    msg,
    sender
  }: {
    amount: Uint128;
    from: string;
    memo?: string;
    msg?: Binary;
    sender: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  registerRewardTokens: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateConfig: ({
    adminAuth,
    epochDuration,
    expiryDuration,
    queryAuth
  }: {
    adminAuth?: RawContract;
    epochDuration?: number;
    expiryDuration?: number;
    queryAuth?: RawContract;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  recoverFunds: ({
    amount,
    msg,
    to,
    token
  }: {
    amount: Uint128;
    msg?: Binary;
    to: string;
    token: TokenType;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  recoverExpiredFunds: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class Sg721Client extends Sg721QueryClient implements Sg721Interface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.claimRewards = this.claimRewards.bind(this);
    this.endEpoch = this.endEpoch.bind(this);
    this.unstake = this.unstake.bind(this);
    this.snip1155Receive = this.snip1155Receive.bind(this);
    this.receive = this.receive.bind(this);
    this.registerRewardTokens = this.registerRewardTokens.bind(this);
    this.updateConfig = this.updateConfig.bind(this);
    this.recoverFunds = this.recoverFunds.bind(this);
    this.recoverExpiredFunds = this.recoverExpiredFunds.bind(this);
  }

  claimRewards = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      claim_rewards: {}
    }, fee, memo, _funds);
  };
  endEpoch = async ({
    epochIndex,
    rewardsDistribution
  }: {
    epochIndex: number;
    rewardsDistribution: RewardsDistribution;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      end_epoch: {
        epoch_index: epochIndex,
        rewards_distribution: rewardsDistribution
      }
    }, fee, memo, _funds);
  };
  unstake = async ({
    amounts,
    tokenIds
  }: {
    amounts: Uint256[];
    tokenIds: number[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unstake: {
        amounts,
        token_ids: tokenIds
      }
    }, fee, memo, _funds);
  };
  snip1155Receive = async ({
    amount,
    from,
    memo,
    msg,
    sender,
    tokenId
  }: {
    amount: Uint256;
    from: Addr;
    memo?: string;
    msg?: Binary;
    sender: Addr;
    tokenId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      snip1155_receive: {
        amount,
        from,
        memo,
        msg,
        sender,
        token_id: tokenId
      }
    }, fee, memo, _funds);
  };
  receive = async ({
    amount,
    from,
    memo,
    msg,
    sender
  }: {
    amount: Uint128;
    from: string;
    memo?: string;
    msg?: Binary;
    sender: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      receive: {
        amount,
        from,
        memo,
        msg,
        sender
      }
    }, fee, memo, _funds);
  };
  registerRewardTokens = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      register_reward_tokens: {}
    }, fee, memo, _funds);
  };
  updateConfig = async ({
    adminAuth,
    epochDuration,
    expiryDuration,
    queryAuth
  }: {
    adminAuth?: RawContract;
    epochDuration?: number;
    expiryDuration?: number;
    queryAuth?: RawContract;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_config: {
        admin_auth: adminAuth,
        epoch_duration: epochDuration,
        expiry_duration: expiryDuration,
        query_auth: queryAuth
      }
    }, fee, memo, _funds);
  };
  recoverFunds = async ({
    amount,
    msg,
    to,
    token
  }: {
    amount: Uint128;
    msg?: Binary;
    to: string;
    token: TokenType;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      recover_funds: {
        amount,
        msg,
        to,
        token
      }
    }, fee, memo, _funds);
  };
  recoverExpiredFunds = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      recover_expired_funds: {}
    }, fee, memo, _funds);
  };
}